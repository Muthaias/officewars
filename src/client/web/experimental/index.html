<html>
    <head>
        <meta charset="UTF-8">
        <title>OfficeWars</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"
            integrity="sha512-NLtnLBS9Q2w7GKK9rKxdtgL7rA7CAS85uC/0xd9im4J/yOL4F9ZVlv634NAM7run8hz3wI2GabaA6vv8vJtHiQ=="
            crossorigin="anonymous"
        ></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"
            crossorigin="anonymous"
        ></script>
        <script src="../lazy-client.js"></script>
        <script src="officewars.js"></script>
        <script src="api.js"></script>
<style>
body {
    padding: 0;
    margin: 0;
    font-family: Verdana, Geneva, Tahoma, sans-serif;
    background: #000;
}

* {
    box-sizing: border-box;
}

#play-button {
    border-radius: 50%;
    width: 50px;
    height: 50px;
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: rgba(0,0,0,0.6);
    z-index: 10;
    transition: background-color 0.2s;
    border: solid 5px rgba(255, 255, 255, 0.8);
}

#play-button:hover {
    background-color: rgba(255,255,255,0.6);
}

#play-button::after {
    content: "";
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0; 
    height: 0; 
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    border-left: 12px solid #fff;
    transform: translateX(-50%) translateY(-50%);
    transition: border-left 0.2s;
}

#play-button:hover::after {
    border-left: 12px solid #000;
}

#leader-board {
    position: absolute;
    top: 15px;
    left: 15px;
}

#leader-board > .entry {
    display: block;
    clear: both;
}

#leader-board > .entry > .name {
    position: relative;
    display: block;
    color: #fff;
    padding: 10px;
    margin-bottom: 5px;
    margin-right: 5px;
    background-color: rgba(0, 0, 0, 0.6);
    transition: background-color 0.2s, color 0.2s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    float: left;
}
#leader-board > .entry:hover > .name {
    color: #000;
    background-color: rgba(255, 255, 255, 0.6);
} 
#leader-board > .entry > .name > .dot {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin-right: 10px;
    border: solid 2px rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    background-color: #f00;
    transition: background-color 0.2s, border-color 0.2s;
}
#leader-board > .entry:hover > .name > .dot {
    border-color: rgba(0, 0, 0, 0.6);
    background-color: #f00;
}
#leader-board > .entry > .points {
    display: block;
    padding: 10px;
    color: #000;
    margin-right: 5px;
    min-width: 40px;
    text-align: center;
    background-color: rgba(255, 255, 255, 0.6);
    float: left;
}
#game-list {
    display: none;
    text-align: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateX(-50%) translateY(-50%);
    padding: 20px;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.6);
    width: 300px;
}
#game-list > h2 {
    margin: 0;
    padding: 0;
    margin-bottom: 10px;
}
#game-list > .entry > .game-name {
    padding: 10px;
    display: block;
    text-align: center;
    text-decoration: none;

    transition: background-color 0.2s, color 0.2s;

    color: #000;
    background-color: rgba(255, 255, 255, 0.6);
    
    margin-bottom: 5px;
}
#game-list > .entry:last-child > .game-name{
    margin-bottom: 0;
}
#game-list > .entry > .game-name:hover {
    padding: 10px;
    display: block;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.6);
}
</style>
    </head>
    <body>
        <div id="app">
            <div id="leader-board">
            </div>
            <div id="game-list">
            </div>
        </div>
    </body>
    <script>
function playMusic() {
    const music = document.getElementById("bg-music")
    music.play()
}

function showPlayers(game, state = 0) {
    const lb = document.getElementById("leader-board")
    const playerPoints = game.players.map(player => [
        player,
        Array.from(
            game.states[state].ownedBy.values()
        ).filter(v => v === player).length
    ]).sort(([a, ap], [b, bp]) => bp - ap)
    const content = playerPoints.map(([player, points]) => (
        `
<div class="entry">
    <span class="points">${points}</span>
    <span class="name">
        <span class="dot" style="background-color:${player.color}"></span>
        ${player.name}
    </span>
</div>
`
    )).join("\n")
    lb.innerHTML = content
}

function showGameList(games) {
    const gl = document.getElementById("game-list")
    const content = games.map((game) => (
        `
<div class="entry">
    <a class="game-name" href="?game=${game.id}">
        ${game.name}
    </a>
</div>
`
    )).join("\n")
    gl.style.display = "block"
    gl.innerHTML = `
<h2>Game list</h2>
${content}
`
}

async function loadConfig() {
    const defaults = {
        baseUrl: "/cgi-bin/server/state/",
        textures: {
            planets: [
                "https://images.unsplash.com/photo-1544611910-3cb8d15aa90e?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1579706624295-3c81eaef2533?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1581553804801-e46ad9c6a60f?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1618260589896-e6f55a14e730?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1547556987-f3de424ebfbb?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1616649357435-aca0f077e487?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1553949345-eb786bb3f7ba?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1607594682446-2c4d5fc5644e?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1617058074336-221c74dbb7c1?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1501166222995-ff31c7e93cef?fit=crop&w=512&q=80",
                "https://images.unsplash.com/photo-1523447704114-37cea08ee064?fit=crop&w=512&q=80",
            ],
            space: "https://images.unsplash.com/photo-1505506874110-6a7a69069a08?fit=crop&w=1024&q=80",
            connection: "https://images.unsplash.com/photo-1612107660524-c163953f7e07?fit=crop&w=512&q=80"
        }
    }
    try {
        const configData = await (
            await fetch("config.json")
        ).json()
        return {
            ...defaults,
            ...configData,
            textures: {
                ...defaults.textures,
                ...(configData.textures || {})
            }
        }
    } catch (e) {
        return defaults
    }
}

function initBase(config, center) {
    const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 )
    const scene = new THREE.Scene()
    
    const textureLoader = new THREE.TextureLoader()
    const spaceTexture = textureLoader.load(
        config.textures.space
    );
    spaceTexture.wrapS = THREE.RepeatWrapping;
    spaceTexture.wrapT = THREE.RepeatWrapping;
    spaceTexture.repeat.set(2, 1)
    const spaceMaterial = new THREE.MeshBasicMaterial({
        map: spaceTexture,
        side: THREE.BackSide
    })
    const spaceGeometry = new THREE.SphereGeometry(
        800, 20, 10
    );
    const space = new THREE.Mesh(
        spaceGeometry,
        spaceMaterial
    );
    space.position.set(...center)
    scene.add(space)
    return {
        scene,
        camera,
        textureLoader
    }
}

function initRenderer() {
    const renderer = new THREE.WebGLRenderer( { antialias: true } )
    renderer.setPixelRatio( window.devicePixelRatio )
    renderer.setSize( window.innerWidth, window.innerHeight )
    document.body.appendChild( renderer.domElement )
    return renderer
}

function initControls(renderer, camera, center) {
    const controls = new THREE.OrbitControls( camera, renderer.domElement )
    camera.position.set(0, 0, 10);
    console.log(center)
    controls.target.set(...center)
    controls.update();
    return controls;
}

async function showGames() {
    const api = await ClientApi.fromModule(Module)
    const config = await loadConfig()
    const gameList = await api.loadGameList(config.baseUrl + "/games")
    const games = Array.from(
        {length: gameList.gameCount()}
    ).map((_, index) => (
        {
            index: index,
            ...gameList.getGame(index)
        }
    ))
    console.log("games", games)
    showGameList(games)
    const center = [0, 0, 0]
    const {
        scene,
        camera,
    } = initBase(config, center)
    const renderer = initRenderer()
    const controls = initControls(renderer, camera, center)

    function animate() {
        requestAnimationFrame(animate)
        renderer.render(scene, camera)
        controls.update()
    }
    animate()
}

async function start(gameId) {
    const api = await ClientApi.fromModule(Module)
    const config = await loadConfig()
    const gi = await api.loadGame(config.baseUrl + "/state/" + gameId)
    const game = Game.fromGameInspector(gi)
    const stateParam = urlParams.get("state")
    const selectedState = stateParam ? Math.max(
        0,
        Math.min(
            parseInt(stateParam),
            game.states.length - 1
        )
    ) : game.states.length - 1
    console.log("Game:", gameId, "State:", selectedState)
    let camera, scene, renderer;
    let mesh;
    let controls;
    const connectionTextureSpeeds = [-0.01, 0.0025, -0.005]
    let connectionTextures = [];
    let planets = []

    init()
    animate()
    showPlayers(game, selectedState)

    function init() {
        const center = game.nodes.map(n => n.position).reduce(
            (acc, p) => acc.map((v, i) => v + p[i])
        ).map(v => v / game.nodes.length)
        const base = initBase(config, center)
        camera = base.camera
        scene = base.scene
        textureLoader = base.textureLoader

        const planetTextures = config.textures.planets.map(url => textureLoader.load(url))
        const outlineMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide})
        outlineMaterial.color = new THREE.Color("#000000")
        for (const pt of planetTextures) {
            pt.wrapS = THREE.RepeatWrapping;
            pt.wrapT = THREE.RepeatWrapping;
            pt.repeat.set(2, 1)
        }
        const planetSizes = [
            0.5,
            0.4,
            0.3,
            0.55,
            0.45
        ]
        const outlineGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r + 0.025, 20, 10)
        ))
        const containerGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r + 0.175, 20, 10)
        ))
        const ownerGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r + 0.15, 20, 10)
        ))
        const planetGeometries = planetSizes.map(r => (
            new THREE.SphereGeometry(r, 20, 10)
        ))
        const planetMaterials = planetTextures.map(tex => (
            new THREE.MeshBasicMaterial({ map: tex })
        ))
        const lastState = game.states[selectedState]
        planets = game.nodes.map((node, nodeId) => {
            const planet = new THREE.Group()
            const owner = lastState.ownedBy.get(node)
            const selectionMaterial = outlineMaterial.clone()
            const planetOutlineMaterial = outlineMaterial.clone()
            planetOutlineMaterial.color = new THREE.Color(
                owner ? owner.color : "#FFFFFF" 
            )
            if (owner) {
                const ownerView = new THREE.Mesh(
                    ownerGeometries[nodeId % planetSizes.length],
                    planetOutlineMaterial
                )
                const container = new THREE.Mesh(
                    containerGeometries[nodeId % planetSizes.length],
                    selectionMaterial
                )
                container.gameNode = node
                planet.add(
                    container,
                    ownerView
                )
            }

            const selection = new THREE.Mesh(
                outlineGeometries[nodeId % planetSizes.length],
                selectionMaterial
            )
            selection.gameNode = node
            const currentPlanetMaterial = planetMaterials[nodeId % planetMaterials.length].clone()
            currentPlanetMaterial.color = planetOutlineMaterial.color
            const core = new THREE.Mesh(
                planetGeometries[nodeId % planetSizes.length],
                currentPlanetMaterial
            )
            planet.add(
                selection,
                core,
            )
            planet.position.set(...node.position.map(v => v))
            scene.add(planet)
            return {
                group: planet,
                selection: selection,
                core: core,
            }
        })

        
        connectionTextures = connectionTextureSpeeds.map(s => {
            const tex = textureLoader.load(
                config.textures.connection
            )
            tex.wrapS = THREE.RepeatWrapping
            tex.wrapT = THREE.RepeatWrapping
            return tex
        })
        const connectionMaterials = connectionTextures.map(tex => (
            new THREE.MeshBasicMaterial(
                {
                    map: tex,
                    blending: THREE.AdditiveBlending
                }
            )
        ))
        for (const nodeId in game.nodes) {
            const node = game.nodes[nodeId]
            const nodeVec = new THREE.Vector3(...node.position)
            for (const target of node.connections) {
                const targetVec = new THREE.Vector3(...target.position)
                const distance = nodeVec.distanceTo(targetVec)
                const size = planetSizes[nodeId % planetSizes.length]
                const variants = [1, 0.7, 0.35]
                for (const variantId in variants) {
                    const variant = variants[variantId]
                    const connectionGeometry = new THREE.ConeGeometry( 0.1 * size * Math.pow(2 - variant, 4), distance * 0.55 * variant, 10 )
                    connectionGeometry.applyMatrix4(
                        new THREE.Matrix4().makeTranslation(0, variant * distance * 0.275, 0)
                    );
                    const connection = new THREE.Mesh(
                        connectionGeometry,
                        connectionMaterials[variantId % connectionMaterials.length]
                    );
                    connection.position.set(...[
                        node.position[0],
                        node.position[1],
                        node.position[2]
                    ])
                    const vector = new THREE.Vector3().subVectors(targetVec, nodeVec)
                    const axis = new THREE.Vector3(0, 1, 0);
                    connection.quaternion.setFromUnitVectors(axis, vector.clone().normalize());
                    scene.add( connection );
                }
            }
        }

        renderer = initRenderer()
        raycaster = new THREE.Raycaster();
        renderer.domElement.addEventListener( 'click', raycastFunc(selectHandler), false )

        controls = initControls(renderer, camera, center)

        window.addEventListener( 'resize', onWindowResize )

    }

    function raycastFunc(handler = () => {}) {
        const raycaster = new THREE.Raycaster()
        raycast = function(e) {
            const mouse = {
                x: ( e.clientX / window.innerWidth ) * 2 - 1,
                y: -( e.clientY / window.innerHeight ) * 2 + 1,
            }
            raycaster.setFromCamera( mouse, camera )
            const intersects = raycaster.intersectObjects(
                scene.children.flatMap(c => [c, ...c.children])
            )

            handler(intersects)
        }
        return raycast
    }

    function selectHandler(intersects) {
        const [nodeObject, ...others] = intersects.filter(
            i => !!i.object.gameNode
        ).map(i => i.object)

        if (nodeObject) {
            planets.forEach(p => p.selection.material.color.setRGB(0, 0, 0))
            nodeObject.material.color.setRGB(1, 1, 1)
        }
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {

        requestAnimationFrame( animate );
        for (const texId in connectionTextures) {
            const tex = connectionTextures[texId]
            const speed = connectionTextureSpeeds[texId]
            tex.offset.set(...[
                tex.offset.x + speed * 0.5,
                tex.offset.y - speed * 0.05
            ])
        }
        const speeds = [1, 0.5, 0.7, 0.2, 0.9]
        const vecs = [
            new THREE.Vector3(0, 1, 0.5).normalize(),
            new THREE.Vector3(1, 1, 0).normalize(),
            new THREE.Vector3(0.5, 0, 1).normalize()
        ]
        for (const planetId in planets) {
            const planet = planets[planetId]
            const quaternion = new THREE.Quaternion()
            quaternion.setFromAxisAngle(
                vecs[planetId % vecs.length],
                Math.PI * speeds[planetId % speeds.length] * 0.0025
            )
            planet.core.applyQuaternion(quaternion)
        }
        controls.update();

        renderer.render( scene, camera );

    }
}

const queryString = window.location.search
const urlParams = new URLSearchParams(queryString)
const gameId = urlParams.get("game")
if (gameId) {
    start(gameId)
} else {
    showGames()
}

    </script>
</html>